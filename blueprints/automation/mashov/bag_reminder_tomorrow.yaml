blueprint:
  name: Mashov – Bag Reminder (Speak Tomorrow's Subjects)
  description: >
    Version v1.0.32. Reads tomorrow's subjects (with teacher names and optional plan) aloud at 18:00,
    only if tomorrow is a school day (not Saturday and not a holiday) and only if
    there is data for tomorrow. Raises speaker volume, speaks, then restores it.
    Includes detailed trace/logbook of "why ran / why skipped" and prints holiday name when skipping.
    Added option to include/exclude weekly plan in announcement. Fixed TTS timing: waits for speaker to start playing, then waits until idle before restoring volume.
  domain: automation
  source_url: https://raw.githubusercontent.com/NirBY/ha-mashov/main/blueprints/automation/mashov/bag_reminder_tomorrow.yaml
  input:
    timetable_entity:
      name: Timetable sensor (Mashov)
      description: sensor.mashov_<studentID>_timetable
      selector: { entity: { domain: sensor } }
    weekly_plan_entity:
      name: Weekly Plan sensor (Mashov)
      description: sensor.mashov_<studentID>_weekly_plan (optional but recommended for lesson plan text)
      default: ""
      selector: { entity: { domain: sensor } }
    holiday_entity:
      name: Holidays sensor
      description: sensor.mashov_holidays (with Items[] start/end/name)
      selector: { entity: { domain: sensor } }
    speaker_entity:
      name: Speaker / media_player
      selector: { entity: { domain: media_player } }
    daily_time:
      name: Speak time (local)
      description: Runs once a day at this time (default 18:00)
      default: "18:00:00"
      selector: { time: {} }
    quiet_window_start:
      name: Night quiet start (don’t run after)
      default: "22:00:00"
      selector: { time: {} }
    quiet_window_end:
      name: Night quiet end (don’t run before)
      default: "07:00:00"
      selector: { time: {} }
    max_volume:
      name: Max volume (0.0–1.0)
      default: 1.0
      selector: { number: { min: 0, max: 1, step: 0.01, mode: slider } }
    restore_volume_default:
      name: Fallback volume if previous unknown (0.0–1.0)
      default: 0.3
      selector: { number: { min: 0, max: 1, step: 0.01, mode: slider } }
    use_previous_volume:
      name: Restore to previous volume (preferred)
      description: If true, restore to the volume captured just before speaking; else restore to fallback value.
      default: true
      selector: { boolean: {} }
    tts_service_type:
      name: TTS service
      description: Choose your TTS. For Google Translate use Hebrew code **iw** (cloud_say prefers **he-IL**).
      default: google_translate
      selector:
        select:
          options:
            - google_translate
            - cloud_say
    language_code:
      name: TTS language code
      description: For Google Translate Hebrew use **iw** (default). For cloud_say use **he-IL**.
      default: iw
      selector: { text: {} }
    include_weekly_plan:
      name: Include weekly plan in announcement
      description: If enabled, will read the lesson plan (תוכנית השיעור) for each subject. If disabled, will only read subject names.
      default: true
      selector: { boolean: {} }
    tts_start_timeout:
      name: TTS start timeout (seconds)
      description: How long to wait for speaker to start playing after TTS call (default 10 seconds)
      default: 10
      selector: { number: { min: 3, max: 30, step: 1, mode: slider } }
    tts_finish_timeout:
      name: TTS finish timeout (seconds)
      description: How long to wait for speaker to become idle after playing (default 300 seconds / 5 minutes)
      default: 300
      selector: { number: { min: 30, max: 600, step: 10, mode: slider } }

    bp_version_info:
      name: Blueprint version
      description: Informational only; used in traces. Do not change.
      default: "bag_reminder_tomorrow v1.0.32 (2025-10-18)"
      selector: { text: {} }

mode: single
trace:
  stored_traces: 50

trigger:
  - platform: time
    at: !input daily_time

variables:
  timetable_entity: !input timetable_entity
  weekly_plan_entity: !input weekly_plan_entity
  holiday_entity: !input holiday_entity
  speaker_entity: !input speaker_entity
  # Blueprint version for trace/debug (from form)
  blueprint_version: !input bp_version_info
  quiet_start: !input quiet_window_start
  quiet_end: !input quiet_window_end
  max_volume: !input max_volume
  restore_volume_default: !input restore_volume_default
  use_previous_volume: !input use_previous_volume
  tts_service_type: !input tts_service_type
  language_code: !input language_code
  include_weekly_plan: !input include_weekly_plan
  tts_start_timeout: !input tts_start_timeout
  tts_finish_timeout: !input tts_finish_timeout

  # Normalize language for Google Translate: map deprecated "iw" -> "he"
  lang_effective: >-
    {% set lc = (language_code | lower) %}
    {{ lc }}

  # Cloud TTS sometimes requires locale (e.g., he-IL). Provide a minimal mapping.
  cloud_lang_effective: >-
    {% set lc = lang_effective %}
    {% if lc in ['he','iw','he-il','iw-il'] %}
      he-IL
    {% elif lc == 'en' %}
      en-US
    {% else %}
      {{ lc }}
    {% endif %}

  # Google Translate TTS sometimes expects 'iw' for Hebrew. Map accordingly.
  google_lang_effective: >-
    {% set lc = lang_effective %}
    {{ lc }}

  # Compute tomorrow (LOCAL timezone; do not force UTC)
  tomorrow_date_iso: "{{ (as_timestamp(now()) + 86400) | timestamp_custom('%Y-%m-%d') }}"
  # %w => 0..6 (Sun=0) in LOCAL timezone. Mashov day: Sun=1..Sat=7
  tomorrow_w: "{{ ((as_timestamp(now()) + 86400) | timestamp_custom('%w') | int) }}"
  tomorrow_day_mashov: "{{ 1 if tomorrow_w == 0 else tomorrow_w + 1 }}"

  # Night guard (don’t run outside quiet_end..quiet_start)
  now_tod: "{{ now().strftime('%H:%M:%S') }}"
  is_night_block: >
    {% set a = quiet_end %}
    {% set b = quiet_start %}
    {# allow when a <= now < b; block otherwise #}
    {% set allow = (now_tod >= a) and (now_tod < b) %}
    {{ not allow }}

  # Is tomorrow Saturday?
  is_tomorrow_sat: "{{ tomorrow_day_mashov | int == 7 }}"

  # Holiday detection (LOCAL dates). Treat end date as INCLUSIVE (common calendars).
  is_tomorrow_holiday: >-
    {% set tdate = tomorrow_date_iso %}
    {% set items = (state_attr(holiday_entity,'Items') or state_attr(holiday_entity,'items') or []) %}
    {% for it in items if (it.start is defined) %}
      {% set s = (it.start | as_datetime).date().isoformat() %}
      {% set e = (it.end   | as_datetime).date().isoformat() if (it.end is defined and it.end) else s %}
      {% if tdate >= s and tdate <= e %}
        {{ true }}
      {% endif %}
    {% endfor %}
    {{ false }}
  tomorrow_holiday_name: >-
    {% set tdate = tomorrow_date_iso %}
    {% for it in (state_attr(holiday_entity,'Items') or state_attr(holiday_entity,'items') or []) %}
      {% set s = (it.start | as_datetime).date().isoformat() if it.start is defined else none %}
      {% set e = (it.end   | as_datetime).date().isoformat() if it.end is defined else s %}
      {% if s and tdate >= s and tdate <= e %}
        {{ it.name or it.holidayName or it.hollyDayName }}
      {% endif %}
    {% endfor %}

  # Student name from data (trim anything after "(" if present)
  student_name: >-
    {% set raw = state_attr(timetable_entity, 'Student name')
        or state_attr(timetable_entity, 'student_name')
        or state_attr(timetable_entity, 'full_name')
        or state_attr(timetable_entity, 'name')
        or state_attr(timetable_entity, 'friendly_name')
        or 'תלמיד/ה' %}
    {{ (raw | string).split('(')[0].strip() }}

  # Pull tomorrow's timetable entries: use bracket notation + namespace for counters
  tomorrow_lessons: >-
    {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
    {% set ns = namespace(out=[], checked=0, matched=0) %}
    {% for it in items %}
      {% if 'timeTable' in it and 'day' in it['timeTable'] %}
        {% set ns.checked = ns.checked + 1 %}
        {% set tt = it['timeTable'] %}
        {% if ((tt['day'] | int) == (tomorrow_day_mashov | int)) %}
          {% set ns.matched = ns.matched + 1 %}
          {% set gd = it['groupDetails'] if 'groupDetails' in it else none %}
          {% set subject = (
                gd['subjectName'] if gd and 'subjectName' in gd
                else (gd['groupName'] if gd and 'groupName' in gd
                else 'מקצוע לא ידוע')
            ) %}
          {% set teachers = it['groupTeachers'] if 'groupTeachers' in it else [] %}
          {% set teacher = (
                teachers[0]['teacherName'] if (teachers | length) > 0 and 'teacherName' in teachers[0]
                else 'מורה'
            ) %}
          {% set item = dict(lesson=tt['lesson'], groupId=tt['groupId'], subject=subject, teacher=teacher, _checked=ns.checked, _matched=ns.matched) %}
          {% set ns.out = ns.out + [item] %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {{ ns.out }}

  # Data presence for tomorrow (define BEFORE subjects and speech)
  has_data_cnt: >-
    {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
    {% set cnt = (items
      | selectattr('timeTable','defined')
      | map(attribute='timeTable')
      | selectattr('day','defined')
      | selectattr('day','in', [ (tomorrow_day_mashov | int), ((tomorrow_day_mashov | int) | string) ])
      | list | count) %}
    {{ cnt }}
  has_tomorrow_data: "{{ (has_data_cnt | int(0)) > 0 }}"

  # Unique subjects for tomorrow: prefer tomorrow_lessons; fallback to Items if empty
  tomorrow_subjects_unique: >-
    {% set subs1 = (tomorrow_lessons | map(attribute='subject') | list) %}
    {% if (subs1 | length) > 0 %}
      {{ subs1 | map('string') | map('trim') | reject('equalto','') | unique | list }}
    {% else %}
      {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
      {% set subs2 = [] %}
      {% for it in items %}
        {% if 'timeTable' in it and 'day' in it['timeTable'] %}
          {% set d = (it['timeTable']['day'] | int) %}
          {% if d == (tomorrow_day_mashov | int) %}
            {% set gd = it['groupDetails'] if 'groupDetails' in it else none %}
            {% set subject = (
                  gd['subjectName'] if gd and 'subjectName' in gd
                  else (gd['groupName'] if gd and 'groupName' in gd
                  else 'מקצוע לא ידוע')
              ) %}
            {% set subs2 = subs2 + [ (subject | string | trim) ] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {{ subs2 | reject('equalto','') | unique | list }}
    {% endif %}

  # Count of unique subjects for tomorrow and speak guard
  subjects_cnt: "{{ (tomorrow_subjects_unique | length) }}"
  should_speak: "{{ (has_tomorrow_data and (subjects_cnt | int(0)) > 0) }}"
  should_run: "{{ (not is_night_block) and (not is_tomorrow_sat) and (not is_tomorrow_holiday) and has_tomorrow_data }}"

  # Build speech text (Hebrew) with optional plan, sorted by lesson number
  speech_text: >-
    {% set base_lessons = tomorrow_lessons | sort(attribute='lesson') %}
    {% set plans = state_attr(weekly_plan_entity, 'Items') or state_attr(weekly_plan_entity, 'items') or [] %}
    {% set plans_today = [] %}
    {% if include_weekly_plan and weekly_plan_entity and plans %}
      {% set plans_today = plans
          | selectattr('lesson_date','defined')
          | selectattr('plan','defined')
          | selectattr('lesson_date', 'search', '^' ~ tomorrow_date_iso )
          | list
      %}
    {% endif %}
    {% if (base_lessons | length) > 0 %}
      {% set header = 'שלום ' ~ student_name ~ ', אנא לסדר תיק למחר. המקצועות למחר: ' %}
      {% set ns = namespace(parts=[], seen=[]) %}
      {% for les in base_lessons %}
        {% set subj = les['subject'] if 'subject' in les else 'מקצוע' %}
        {% set lesson_num = les['lesson'] if 'lesson' in les else 0 %}
        {% if subj not in ns.seen %}
          {% set ns.seen = ns.seen + [subj] %}
          {% set gid = les['groupId'] if 'groupId' in les else none %}
          {% set ns_inner = namespace(plan_text='') %}
          {% if include_weekly_plan %}
            {% for p in plans_today %}
              {% set p_gid = (p.group_id if 'group_id' in p else (p.groupId if 'groupId' in p else none)) %}
              {% set p_plan = (p.plan if 'plan' in p else '') %}
              {% if p_gid == gid and p_plan %}
                {% set ns_inner.plan_text = p_plan | trim %}
              {% endif %}
            {% endfor %}
          {% endif %}
          {% set full = 'שיעור ' ~ lesson_num ~ ': ' ~ subj ~ (('. תוכנית: ' ~ ns_inner.plan_text) if ns_inner.plan_text else '') %}
          {% set ns.parts = ns.parts + [full] %}
        {% endif %}
      {% endfor %}
      {{ header ~ (ns.parts | join(', ')) ~ '.' }}
    {% else %}
      {% set hi = 'שלום ' ~ student_name ~ '. ' %}
      {% if is_tomorrow_sat %}
        {{ hi ~ 'מחר שבת, אין לימודים.' }}
      {% elif is_tomorrow_holiday %}
        {{ hi ~ 'מחר חופש' ~ (': ' ~ (tomorrow_holiday_name or '') if (tomorrow_holiday_name | default('') | trim | length > 0) else '.') }}
      {% elif (has_data_cnt | int(0)) == 0 %}
        {{ hi ~ 'אין נתוני מערכת שעות למחר.' }}
      {% else %}
        {{ hi ~ 'אין פרטי שיעורים זמינים לרגע זה.' }}
      {% endif %}
    {% endif %}

  

  # Pretty reasons for trace/log
  trace_summary: >-
    {% set reasons = [] %}
    {% set reasons = reasons + ['bp_ver=' ~ blueprint_version] %}
    {% set reasons = reasons + ['night_block=' ~ (is_night_block | string)] %}
    {% set reasons = reasons + ['tomorrow_sat=' ~ (is_tomorrow_sat | string)] %}
    {% set reasons = reasons + ['tomorrow_holiday=' ~ (is_tomorrow_holiday | string)] %}
    {% set reasons = reasons + ['tomorrow_day=' ~ (tomorrow_day_mashov | string)] %}
    {% set reasons = reasons + ['tts=' ~ tts_service_type] %}
    {% set tts_lang = (
      cloud_lang_effective if tts_service_type == 'cloud_say'
      else (google_lang_effective if tts_service_type == 'google_translate' else lang_effective)
    ) %}
    {% set reasons = reasons + ['tts_lang=' ~ tts_lang] %}
    {% set reasons = reasons + ['include_weekly_plan=' ~ (include_weekly_plan | string)] %}
    {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
    {% set days = items
      | selectattr('timeTable','defined')
      | map(attribute='timeTable')
      | selectattr('day','defined')
      | map(attribute='day')
      | map('int')
      | list %}
    {% set unique_days = days | unique | list | sort %}
    {% set reasons = reasons + ['days_present=' ~ (unique_days | join('/'))] %}
    {% set rows_cnt = (items | selectattr('timeTable','defined') | list | count) %}
    {% set rows_for_day_cnt = (items
      | selectattr('timeTable','defined')
      | map(attribute='timeTable')
      | selectattr('day','defined')
      | selectattr('day','in', [ (tomorrow_day_mashov | int), ((tomorrow_day_mashov | int) | string) ])
      | list | count) %}
    {% set reasons = reasons + ['rows_cnt=' ~ rows_cnt, 'rows_for_day_cnt=' ~ rows_for_day_cnt, 'has_data_cnt=' ~ (has_data_cnt | string), 'lessons_len=' ~ ((tomorrow_lessons | length) | string)] %}
    {% set subjects_raw_items = (state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [])
      | selectattr('timeTable','defined') | map(attribute='groupDetails')
      | selectattr('subjectName','defined') | map(attribute='subjectName') | list %}
    {% set reasons = reasons + ['subjects_raw=' ~ (subjects_raw_items | join('/'))] %}
    {% set first_item = items[0] if (items | length) > 0 else {} %}
    {% set reasons = reasons + ['items_len=' ~ ((items | length) | string)] %}
    {% set reasons = reasons + ['first_item_keys=' ~ (first_item.keys() | list | join('/'))] %}
    {% set first_has_tt = ('timeTable' in first_item) %}
    {% set first_tt_day = (first_item['timeTable']['day'] if 'timeTable' in first_item and 'day' in first_item['timeTable'] else 'NONE') %}
    {% set reasons = reasons + ['first_has_tt=' ~ (first_has_tt | string), 'first_tt_day=' ~ (first_tt_day | string), 'tomorrow_day=' ~ (tomorrow_day_mashov | string)] %}
    {% set ns_days = namespace(all_days=[]) %}
    {% for it in items %}
      {% if 'timeTable' in it and 'day' in it['timeTable'] %}
        {% set ns_days.all_days = ns_days.all_days + [ (it['timeTable']['day'] | int) ] %}
      {% endif %}
    {% endfor %}
    {% set reasons = reasons + ['all_days=' ~ (ns_days.all_days | join('/'))] %}
    {% set ns_subj = namespace(sfd_temp=[]) %}
    {% for it in items %}
      {% if 'timeTable' in it and 'day' in it['timeTable'] %}
        {% if ((it['timeTable']['day'] | int) == (tomorrow_day_mashov | int)) %}
          {% if 'groupDetails' in it and 'subjectName' in it['groupDetails'] %}
            {% set ns_subj.sfd_temp = ns_subj.sfd_temp + [ it['groupDetails']['subjectName'] ] %}
          {% endif %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {% set reasons = reasons + ['subjects_for_day=' ~ (ns_subj.sfd_temp | join('/'))] %}
    {% set reasons = reasons + ['subjects_cnt=' ~ ((subjects_cnt | int(0)) | string), 'should_speak=' ~ ((should_speak | string) if (should_speak is defined) else 'false'), 'subjects_list=' ~ ((tomorrow_subjects_unique | join('/')))] %}
    {% set plans_all = state_attr(weekly_plan_entity, 'Items') or state_attr(weekly_plan_entity, 'items') or [] %}
    {% set plans_tmr = [] %}
    {% if plans_all %}
      {% set plans_tmr = plans_all
          | selectattr('lesson_date','defined')
          | selectattr('plan','defined')
          | selectattr('lesson_date', 'search', '^' ~ tomorrow_date_iso )
          | list %}
    {% endif %}
    {% set wp_entity_state = states(weekly_plan_entity) if weekly_plan_entity else 'NO_ENTITY' %}
    {% set reasons = reasons + ['weekly_plan_entity=' ~ (weekly_plan_entity | string), 'wp_state=' ~ wp_entity_state, 'plans_all_cnt=' ~ ((plans_all | length) | string), 'plans_tmr_cnt=' ~ ((plans_tmr | length) | string)] %}
    {% set tmr_les_first = tomorrow_lessons[0] if (tomorrow_lessons | length) > 0 else {} %}
    {% set tmr_les_first_subj = tmr_les_first['subject'] if 'subject' in tmr_les_first else 'NONE' %}
    {% set tmr_les_first_lesson = tmr_les_first['lesson'] if 'lesson' in tmr_les_first else 'NONE' %}
    {% set reasons = reasons + ['tmr_les_first_keys=' ~ (tmr_les_first.keys() | list | join('/') if tmr_les_first else 'EMPTY')] %}
    {% set reasons = reasons + ['tmr_les_first_subj=' ~ tmr_les_first_subj, 'tmr_les_first_lesson=' ~ (tmr_les_first_lesson | string)] %}
    {% if is_tomorrow_holiday %}
      {% set reasons = reasons + ['holiday_name=' ~ (tomorrow_holiday_name or 'unknown')] %}
    {% endif %}
    {% set reasons = reasons + ['has_data=' ~ (has_tomorrow_data | string)] %}
    {{ reasons | join(', ') }}

condition: []

action:
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ should_run }}"
        sequence:
          # TRACE: start
          - service: logbook.log
            data:
              name: "Bag Reminder"
              message: "Starting run. {{ trace_summary }}"
              entity_id: !input speaker_entity

          # Audio path only when we actually plan to speak
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ should_speak }}"
                sequence:
                  # Turn on & capture current volume
                  - variables:
                      prev_volume: "{{ state_attr(speaker_entity, 'volume_level') }}"
                      target_volume: "{{ max_volume | float }}"
                  - service: media_player.turn_on
                    target: { entity_id: !input speaker_entity }
                  - wait_template: "{{ states(speaker_entity) != 'off' }}"
                    timeout: "00:00:10"
                    continue_on_timeout: true

                  # Set to max volume
                  - service: media_player.volume_set
                    target: { entity_id: !input speaker_entity }
                    data:
                      volume_level: "{{ target_volume }}"
                  - wait_template: "{{ (state_attr(speaker_entity, 'volume_level') | float(0)) >= (target_volume | float(0)) }}"
                    timeout: "00:00:10"
                    continue_on_timeout: true

                  # Speak (choose TTS engine)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ tts_service_type == 'cloud_say' }}"
                        sequence:
                          - service: tts.cloud_say
                            data:
                              entity_id: !input speaker_entity
                              message: "{{ speech_text }}"
                              language: "{{ cloud_lang_effective }}"
                      - conditions:
                          - condition: template
                            value_template: "{{ tts_service_type == 'google_translate' }}"
                        sequence:
                          - service: tts.google_translate_say
                            data:
                              entity_id: !input speaker_entity
                              message: "{{ speech_text }}"
                              language: "{{ google_lang_effective }}"

                  # Wait for speaker to start playing (TTS might take a moment to begin)
                  - wait_template: "{{ is_state(speaker_entity, 'playing') }}"
                    timeout: "{{ '00:00:' ~ '%02d' | format(tts_start_timeout | int) }}"
                    continue_on_timeout: true

                  # Wait until speaker becomes idle (TTS fully completed)
                  - wait_template: "{{ is_state(speaker_entity, 'idle') }}"
                    timeout: >
                      {% set seconds = tts_finish_timeout | int %}
                      {% set minutes = (seconds // 60) %}
                      {% set secs = (seconds % 60) %}
                      {{ '00:' ~ '%02d' | format(minutes) ~ ':' ~ '%02d' | format(secs) }}
                    continue_on_timeout: true

                  # Restore volume (previous if available, else fallback)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_previous_volume and (prev_volume is number) }}"
                        sequence:
                          - service: media_player.volume_set
                            target: { entity_id: !input speaker_entity }
                            data:
                              volume_level: "{{ prev_volume | float }}"
                      - conditions: []
                        sequence:
                          - service: media_player.volume_set
                            target: { entity_id: !input speaker_entity }
                            data:
                              volume_level: "{{ restore_volume_default | float }}"

          # TRACE: done
          - service: logbook.log
            data:
              name: "Bag Reminder"
              message: >-
                Completed. Lessons={{ (tomorrow_lessons | length) }}.
                Restored volume={{ (use_previous_volume and (prev_volume is number)) | iif(prev_volume, restore_volume_default) }}.
              entity_id: !input speaker_entity
          - service: system_log.write
            data:
              level: info
              logger: custom_components.mashov.bag_reminder
              message: >-
                Bag Reminder run OK | {{ trace_summary }} | Speech="{{ speech_text }}"

    default:
      # TRACE: skipped (print which holiday if applicable)
      - service: logbook.log
        data:
          name: "Bag Reminder"
          message: >-
            Skipped. {{ trace_summary }} | Speech="{{ speech_text }}"
          entity_id: !input speaker_entity
      - service: system_log.write
        data:
          level: warning
          logger: custom_components.mashov.bag_reminder
          message: >-
            Skipped bag reminder | {{ trace_summary }} | Speech="{{ speech_text }}"
