blueprint:
  name: Mashov – Bag Reminder (Speak Tomorrow's Subjects)
  description: >
    Reads tomorrow's subjects (with teacher names and optional plan) aloud at 18:00,
    only if tomorrow is a school day (not Saturday and not a holiday) and only if
    there is data for tomorrow. Raises speaker volume, speaks, then restores it.
    Includes detailed trace/logbook of "why ran / why skipped" and prints holiday name when skipping.
  domain: automation
  source_url: https://raw.githubusercontent.com/NirBY/ha-mashov/main/blueprints/automation/mashov/bag_reminder_tomorrow.yaml
  input:
    timetable_entity:
      name: Timetable sensor (Mashov)
      description: sensor.mashov_<studentID>_timetable
      selector: { entity: { domain: sensor } }
    weekly_plan_entity:
      name: Weekly Plan sensor (Mashov)
      description: sensor.mashov_<studentID>_weekly_plan (optional but recommended for lesson plan text)
      default: ""
      selector: { entity: { domain: sensor } }
    holiday_entity:
      name: Holidays sensor
      description: sensor.mashov_holidays (with Items[] start/end/name)
      selector: { entity: { domain: sensor } }
    speaker_entity:
      name: Speaker / media_player
      selector: { entity: { domain: media_player } }
    daily_time:
      name: Speak time (local)
      description: Runs once a day at this time (default 18:00)
      default: "18:00:00"
      selector: { time: {} }
    quiet_window_start:
      name: Night quiet start (don’t run after)
      default: "22:00:00"
      selector: { time: {} }
    quiet_window_end:
      name: Night quiet end (don’t run before)
      default: "07:00:00"
      selector: { time: {} }
    max_volume:
      name: Max volume (0.0–1.0)
      default: 1.0
      selector: { number: { min: 0, max: 1, step: 0.01, mode: slider } }
    restore_volume_default:
      name: Fallback volume if previous unknown (0.0–1.0)
      default: 0.3
      selector: { number: { min: 0, max: 1, step: 0.01, mode: slider } }
    use_previous_volume:
      name: Restore to previous volume (preferred)
      description: If true, restore to the volume captured just before speaking; else restore to fallback value.
      default: true
      selector: { boolean: {} }
    tts_service_type:
      name: TTS service
      description: Choose your TTS. Google Translate uses language code **he** for Hebrew (not iw).
      default: google_translate
      selector:
        select:
          options:
            - google_translate
            - cloud_say
    language_code:
      name: TTS language code
      description: For Google Translate Hebrew use **he**
      default: he
      selector: { text: {} }

mode: single
trace:
  stored_traces: 50

trigger:
  - platform: time
    at: !input daily_time

variables:
  timetable_entity: !input timetable_entity
  weekly_plan_entity: !input weekly_plan_entity
  holiday_entity: !input holiday_entity
  speaker_entity: !input speaker_entity
  quiet_start: !input quiet_window_start
  quiet_end: !input quiet_window_end
  max_volume: !input max_volume
  restore_volume_default: !input restore_volume_default
  use_previous_volume: !input use_previous_volume
  tts_service_type: !input tts_service_type
  language_code: !input language_code

  # Normalize language for Google Translate: map deprecated "iw" -> "he"
  lang_effective: >-
    {% set lc = (language_code | lower) %}
    {{ 'he' if lc in ['iw','he-il','iw-il'] else lc }}

  # Compute tomorrow (LOCAL timezone; do not force UTC)
  tomorrow_date_iso: "{{ (as_timestamp(now()) + 86400) | timestamp_custom('%Y-%m-%d') }}"
  # %w => 0..6 (Sun=0) in LOCAL timezone. Mashov day: Sun=1..Sat=7
  tomorrow_w: "{{ ((as_timestamp(now()) + 86400) | timestamp_custom('%w') | int) }}"
  tomorrow_day_mashov: "{{ 1 if tomorrow_w == 0 else tomorrow_w + 1 }}"

  # Night guard (don’t run outside quiet_end..quiet_start)
  now_tod: "{{ now().strftime('%H:%M:%S') }}"
  is_night_block: >
    {% set a = quiet_end %}
    {% set b = quiet_start %}
    {# allow when a <= now < b; block otherwise #}
    {% set allow = (now_tod >= a) and (now_tod < b) %}
    {{ not allow }}

  # Is tomorrow Saturday?
  is_tomorrow_sat: "{{ tomorrow_day_mashov | int == 7 }}"

  # Holiday detection (LOCAL dates). Treat end date as INCLUSIVE (common calendars).
  is_tomorrow_holiday: >-
    {% set tdate = tomorrow_date_iso %}
    {% set items = (state_attr(holiday_entity,'Items') or state_attr(holiday_entity,'items') or []) %}
    {% for it in items if (it.start is defined) %}
      {% set s = (it.start | as_datetime).date().isoformat() %}
      {% set e = (it.end   | as_datetime).date().isoformat() if (it.end is defined and it.end) else s %}
      {% if tdate >= s and tdate <= e %}
        {{ true }}
      {% endif %}
    {% endfor %}
    {{ false }}
  tomorrow_holiday_name: >-
    {% set tdate = tomorrow_date_iso %}
    {% for it in (state_attr(holiday_entity,'Items') or state_attr(holiday_entity,'items') or []) %}
      {% set s = (it.start | as_datetime).date().isoformat() if it.start is defined else none %}
      {% set e = (it.end   | as_datetime).date().isoformat() if it.end is defined else s %}
      {% if s and tdate >= s and tdate <= e %}
        {{ it.name or it.holidayName or it.hollyDayName }}
      {% endif %}
    {% endfor %}

  # Student name from data (trim anything after "(" if present)
  student_name: >-
    {% set raw = state_attr(timetable_entity, 'Student name')
        or state_attr(timetable_entity, 'student_name')
        or state_attr(timetable_entity, 'full_name')
        or state_attr(timetable_entity, 'name')
        or state_attr(timetable_entity, 'friendly_name')
        or 'תלמיד/ה' %}
    {{ (raw | string).split('(')[0].strip() }}

  # Pull tomorrow's timetable entries (Items[].timeTable) for Mashov day; sort by lesson
  tomorrow_lessons: >-
    {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
    {% set rows = items
      | selectattr('timeTable', 'defined')
      | map(attribute='timeTable')
      | selectattr('day', 'defined')
      | list
    %}
    {% set rows_for_day = [] %}
    {% for tt in rows %}
      {% if (tt.day | int) == (tomorrow_day_mashov | int) %}
        {% set rows_for_day = rows_for_day + [tt] %}
      {% endif %}
    {% endfor %}
    {% set result = [] %}
    {% for tt in rows_for_day %}
      {% set parent = (items | selectattr('timeTable', 'defined') | selectattr('timeTable.groupId','equalto', tt.groupId) | list | first) %}
      {% set subject = parent.groupDetails.subjectName if parent and parent.groupDetails is defined and parent.groupDetails.subjectName is defined else 'מקצוע לא ידוע' %}
      {% set teacher = (
            (parent.groupTeachers|first).teacherName
            if parent and parent.groupTeachers is defined
            and (parent.groupTeachers|list|count) > 0
            and (parent.groupTeachers|first).teacherName is defined
            else 'מורה'
        )
      %}
      {% set item = dict(lesson=tt.lesson, groupId=tt.groupId, subject=subject, teacher=teacher) %}
      {% set result = result + [item] %}
    {% endfor %}
    {{ result }}

  # Optional: add plan text from weekly_plan_entity when the same group_id matches by date
  tomorrow_lessons_with_plan: >-
    {% set plans = state_attr(weekly_plan_entity, 'Items') or [] %}
    {% set plans_today = plans
        | selectattr('lesson_date','defined')
        | selectattr('plan','defined')
        | selectattr('lesson_date', 'search', '^' ~ tomorrow_date_iso )
        | list
    %}
    {% set out = [] %}
    {% for r in tomorrow_lessons %}
      {% set p = (plans_today | selectattr('group_id','equalto', r.groupId) | list | first) %}
      {% set plan = (p.plan if p is defined else '') %}
      {% set merged = dict(r, **{'plan': plan}) %}
      {% set out = out + [merged] %}
    {% endfor %}
    {{ out }}

  # Build speech text (Hebrew)
  speech_text: >-
    {% set lessons = tomorrow_lessons_with_plan %}
    {% if lessons | length > 0 %}
      {% set header = 'שלום ' ~ student_name ~ ', אנא לסדר תיק למחר. המקצועות למחר: ' %}
      {% set parts = [] %}
      {% for l in lessons %}
        {% set base = l.subject ~ ' עם ' ~ l.teacher %}
        {% set full = base ~ ('. תוכנית: ' ~ l.plan if (l.plan | trim | length > 0) else '') %}
        {% set parts = parts + [ full ] %}
      {% endfor %}
      {{ header ~ parts | join('. ') ~ '.' }}
    {% else %}
      {% set hi = 'שלום ' ~ student_name ~ '. ' %}
      {% if is_tomorrow_sat %}
        {{ hi ~ 'מחר שבת, אין לימודים.' }}
      {% elif is_tomorrow_holiday %}
        {{ hi ~ 'מחר חופש' ~ (': ' ~ (tomorrow_holiday_name or '') if (tomorrow_holiday_name | default('') | trim | length > 0) else '.') }}
      {% elif not has_tomorrow_data %}
        {{ hi ~ 'אין נתוני מערכת שעות למחר.' }}
      {% else %}
        {{ hi ~ 'אין פרטי שיעורים זמינים לרגע זה.' }}
      {% endif %}
    {% endif %}

  # Should run?
  has_tomorrow_data: "{{ (tomorrow_lessons | length) > 0 }}"
  should_run: "{{ (not is_night_block) and (not is_tomorrow_sat) and (not is_tomorrow_holiday) and has_tomorrow_data }}"

  # Pretty reasons for trace/log
  trace_summary: >-
    {% set reasons = [] %}
    {% set reasons = reasons + ['night_block=' ~ (is_night_block | string)] %}
    {% set reasons = reasons + ['tomorrow_sat=' ~ (is_tomorrow_sat | string)] %}
    {% set reasons = reasons + ['tomorrow_holiday=' ~ (is_tomorrow_holiday | string)] %}
    {% set reasons = reasons + ['tomorrow_day=' ~ (tomorrow_day_mashov | string)] %}
    {% set items = state_attr(timetable_entity, 'Items') or state_attr(timetable_entity, 'items') or [] %}
    {% set days = items
      | selectattr('timeTable','defined')
      | map(attribute='timeTable')
      | selectattr('day','defined')
      | map(attribute='day')
      | map('int')
      | list %}
    {% set unique_days = days | unique | sort %}
    {% set reasons = reasons + ['days_present=' ~ (unique_days | join('/'))] %}
    {% set rows_cnt = (items | selectattr('timeTable','defined') | list | count) %}
    {% set rows_for_day_cnt = (items
      | selectattr('timeTable','defined')
      | map(attribute='timeTable')
      | selectattr('day','defined')
      | selectattr('day','in', [ (tomorrow_day_mashov | int), ((tomorrow_day_mashov | int) | string) ])
      | list | count) %}
    {% set reasons = reasons + ['rows_cnt=' ~ rows_cnt, 'rows_for_day_cnt=' ~ rows_for_day_cnt] %}
    {% if is_tomorrow_holiday %}
      {% set reasons = reasons + ['holiday_name=' ~ (tomorrow_holiday_name or 'unknown')] %}
    {% endif %}
    {% set reasons = reasons + ['has_data=' ~ (has_tomorrow_data | string)] %}
    {{ reasons | join(', ') }}

condition: []

action:
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ should_run }}"
        sequence:
          # TRACE: start
          - service: logbook.log
            data:
              name: "Bag Reminder"
              message: "Starting run. {{ trace_summary }}"
              entity_id: !input speaker_entity

          # Turn on & capture current volume
          - variables:
              prev_volume: "{{ state_attr(speaker_entity, 'volume_level') }}"
              target_volume: "{{ max_volume | float }}"
          - service: media_player.turn_on
            target: { entity_id: !input speaker_entity }
          - wait_template: "{{ states(speaker_entity) != 'off' }}"
            timeout: "00:00:10"
            continue_on_timeout: true

          # Set to max volume
          - service: media_player.volume_set
            target: { entity_id: !input speaker_entity }
            data:
              volume_level: "{{ target_volume }}"
          - wait_template: "{{ (state_attr(speaker_entity, 'volume_level') | float(0)) >= (target_volume | float(0)) }}"
            timeout: "00:00:10"
            continue_on_timeout: true

          # Speak (choose TTS engine)
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ tts_service_type == 'cloud_say' }}"
                sequence:
                  - service: tts.cloud_say
                    data:
                      entity_id: !input speaker_entity
                      message: "{{ speech_text }}"
                      language: "{{ lang_effective }}"
              - conditions:
                  - condition: template
                    value_template: "{{ tts_service_type == 'google_translate' }}"
                sequence:
                  - service: tts.google_translate_say
                    data:
                      entity_id: !input speaker_entity
                      message: "{{ speech_text }}"
                      language: "{{ lang_effective }}"

          # Wait until TTS finishes (player not playing/buffering)
          - wait_template: >-
              {% set s = states(speaker_entity) %}
              {{ s not in ['playing','buffering'] }}
            timeout: "00:05:00"
            continue_on_timeout: true

          # Restore volume (previous if available, else fallback)
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_previous_volume and (prev_volume is number) }}"
                sequence:
                  - service: media_player.volume_set
                    target: { entity_id: !input speaker_entity }
                    data:
                      volume_level: "{{ prev_volume | float }}"
              - conditions: []
                sequence:
                  - service: media_player.volume_set
                    target: { entity_id: !input speaker_entity }
                    data:
                      volume_level: "{{ restore_volume_default | float }}"

          # TRACE: done
          - service: logbook.log
            data:
              name: "Bag Reminder"
              message: >-
                Completed. Lessons={{ (tomorrow_lessons | length) }}.
                Restored volume={{ (use_previous_volume and (prev_volume is number)) | iif(prev_volume, restore_volume_default) }}.
              entity_id: !input speaker_entity
          - service: system_log.write
            data:
              level: info
              logger: custom_components.mashov.bag_reminder
              message: >-
                Bag Reminder run OK | {{ trace_summary }} | Speech="{{ speech_text }}"

    default:
      # TRACE: skipped (print which holiday if applicable)
      - service: logbook.log
        data:
          name: "Bag Reminder"
          message: >-
            Skipped. {{ trace_summary }} | Speech="{{ speech_text }}"
          entity_id: !input speaker_entity
      - service: system_log.write
        data:
          level: warning
          logger: custom_components.mashov.bag_reminder
          message: >-
            Skipped bag reminder | {{ trace_summary }} | Speech="{{ speech_text }}"
